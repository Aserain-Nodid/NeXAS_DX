# `.mek` 末尾块（S6..EOF, MekPluginBlock）解析复盘

---

## 1) 这块到底是什么？

* **本质**：**素材插槽/素材组清单**。NeXAS引擎把它称作 `CMaterial` 的集合——每个 `CMaterial` 条目都打包了该“状态/武装”需要的**Sprite（动画）/SE（音效）/Voice（语音）**的**分组列表**。
* **作用**：

    * 前面 **7+extra** 个条目对应**可操控机体的常规状态机**（如站立、走路、ND、BD…）；
    * 剩余条目按逻辑被“**1 条或 3 条**”一组地**挂接到各个武装/特殊状态**上（是否 1 条或 3 条由状态/武装的标志位决定）。
* **为什么最早之前用“固定4字节”能切对？**
  因为每个 `CMaterial` 条目的**第 1 个 `u32`**恰好是**第一段（Sprite 段）的组数**，在同一 `.mek` 内通常**恒定**（例如 138/139），看起来就像“魔法值”。但它不是协议定义的哨兵——只是**运气好所以能分对**。

---

## 2) 结构长什么样（伪代码）

### 2.1 末尾块总体（S6..EOF）

```c
// 读取 S6..EOF 为 MekPluginBlock
MekPluginBlock {
    // ① 固定的 7 条
    for (i = 0; i < 7; i++)
        entries.add( readCMaterial(file) );

    // ② 额外常规条目数
    int extra = readInt(file);     // au_re_File::read_2()

    // ③ 再读 extra 条
    for (i = 0; i < extra; i++)
        entries.add( readCMaterial(file) );

    // ④ 直到 EOF 的剩余条目（用于武装/特殊状态的挂接，也就是weapon的演示资源组）
    while (!EOF(file))
        entries.add( readCMaterial(file) );
}
```

> 术语对齐：`regularCount = 7 + extra`。最早之前写的 `regularPluginInfoList` 就是这前 `regularCount` 个条目；其余是 `weaponPluginInfoList`（或“trailing entries”）。

### 2.2 单个 `CMaterial` 条目（由 `CMaterial::readArraysFromFile` 定义）

```c
// 典型的“三段组列表”，每段都是 list-of-list of u32
CMaterial readCMaterial(File f) {
    Groups sprite = readGroups(f);   // 段A（对应 AddSprite）
    Groups se     = readGroups(f);   // 段B（对应 AddSe）
    Groups voice  = readGroups(f);   // 段C（对应 AddVoice）
    return { sprite, se, voice };
}

Groups readGroups(File f) {
    uint32_t groupCount = readU32(f);    // ★ 最早之前看到的“固定4字节”，WEAPON_PLUGINS_FLAG_DATA
    Group groups[groupCount];
    for (i = 0; i < groupCount; i++) {
        uint32_t len = readU32(f);
        uint32_t ids[len];
        for (k = 0; k < len; k++)
            ids[k] = readU32(f);
        groups[i] = ids;
    }
    return groups;
}
```

* 每条目的**总字节数可变**：虽然 `groupCount` 往往恒定，但每组的 `len` 会变化（三段相加），因此条目大小不一样。
* `.rdata` 里的调试字符串（`"AddSprite" / "AddSe" / "AddVoice"`）与三段一一对应，这一段可以从反编译的 `groupCount` 类信息中得到。

---

## 3) 在 IDA 里是怎么锁定它的

> 核心抓手：**`sub_624320(container, ?, index)` 的第三个参数就是“块索引”**。
> 末尾块是 **index=5**，其 reader 就是 **`sub_657800`**。

### 3.1 先用“索引值=5”定位“谁在读这块”

1. **搜索调用** `sub_624320(..., 5u)` 的位置。
2. 打开该调用点的函数，会看到典型的“打开并读取 .mek 文件”的套路：

    * `sub_76C470`（准备文件句柄栈）
    * `sub_76C940(..., ".mek", ...)`（打开同名 `.mek`）
    * `sub_76BFE0`（seek 到该块起点）
    * `File::read / File::read_string`（真正读数据）
3. 这段恰好位于 **`sub_657800`**，所以**它就是末尾块 reader**。

### 3.2 在 `sub_657800` 里识别出“7 固定 + extra + 剩余”的读法

* 前半段反复出现：

  ```c
  v11 = malloc(...);
  v12 = CMaterial_Constructor(...);   // 内部马上调用 CMaterial::readArraysFromFile
  sub_5683E0(&v12);
  ```

  这段**循环 7 次**（对应“7 固定条目”）。
* 接着出现 `au_re_File::read_2(v60)`，反编译可见它本质是 `File::read(..., &int32)` ——这就是 **`extra`**。
* 然后按 `extra` 再构造同样数量的 `CMaterial`。
* 后半段进入“**挂接流程**”（`sub_600640` 等）：

    * 遍历目标集合，检查诸如 `*(*j + 164)`、`*(*j + 120)` 的**标志位**；
    * 若命中某种标志，就**一次消费 3 条** `CMaterial`；否则消费 **1 条**；
    * 这正是“余下条目用于武装/特殊状态”的证据。

### 3.3 打开 `CMaterial_Constructor` → `CMaterial::readArraysFromFile`，核对条目内部结构

* 反编译显示 `CMaterial::readArraysFromFile` 连续读**三段组列表**（每段 `groupCount` → `len` → `ids[len]`）；
* 和 `.rdata` 里的调试字符串 `AddSprite / AddSe / AddVoice` 强吻合；
* 这就是我们把 `CMaterial` 条目定义成“三段 list-of-list of u32”的原因。

### 3.4 用二进制对齐验证（反证“不是魔法值切块”）

* 对样本 `.mek` 的 S6..EOF 区间，用上面的结构逐字节推进：

    * 先读 7 条 → 读 `extra` → 读 `extra` 条 → 继续直到 EOF；
    * 每条内部三段均按“计数→长度→ID表”推进；
    * **刚好对齐到 EOF，没有残留**。
* 再对照之前的“固定4字节”切块：那 4 字节其实是**第一段的 groupCount**，在同一文件里恰好恒定，所以“看起来像魔法值”。
  **结构化解析**才是稳妥做法。

---

## 小结

* **块索引**：末尾块 = `index=5`，reader = `sub_657800`。
* **读取序**：7 固定条目 → 读 `extra` → 再读 `extra` 条 → 直到 EOF 的条目。
* **条目结构**：`CMaterial = Groups(Sprite) + Groups(SE) + Groups(Voice)`；`Groups = groupCount × (len + ids[len])`。
* **后续用途**：前 `7+extra` = 常规状态机；余下按标志**一条或三条**分配到武装/特殊状态。
* **快速验证**：

    * 进入 `sub_657800` 能看到 `CMaterial_Constructor` 与 `CMaterial::readArraysFromFile`；
    * 中途必有 `au_re_File::read_2`（读 `extra`）；
    * 末尾有大量 `sub_600640`（挂接）与标志位分支；
    * `.rdata` 中 `AddSprite/Se/Voice` 与条目内三段一一对应。
